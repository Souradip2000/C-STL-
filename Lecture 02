Date : 16th May, 2023
____________________________________________________________________________________________________________________________________________________________


Set is implemented in c++ using binary search tree(BST).


// Set

Stores only unique elements in ascending order
Cannot directly acces elements as in an arr[index_to_be_accessed]
Use iterators to access elements of the set

insert() can be replaced with emplace().

st.size() gives size of the set.

3 types of erase functions: 
  i. st.erase(iterator);
  ii. st.erase( starting iterator, ending iterator )      // [)
  iii. st.erase( key );     --> key: the element you want to delete from the set
  
 erase() -  time complexity: O(log n)
 
 find( element ) -  returns an iterator to the element 
                    if element is not present, the find function returns st.end()

Code:

set<int> st;
int n;
cin>>n;
for(int i=0; i<n; i++)
{
  int x;
  cin>>x;
  
  st.insert(x);   --> insert function is used to insert an element into the set
                      This insert function uses O(log n) time complexity
                      
  *st.begin()+2   --> access elements in a set using iterators
  
  
  st.erase(st.begin(),st.begin()+2);    --> syntax: st.erase(iterator)  --> removes the elements    // [ starting itr, ending itr )
  st.erase(4);  // 4 element will be deleted from the set
  
  auto it = st.find(7);
}






We can initialse set with any data type, including struct.

for(auto it=st.begin(); it!=st.end(); it++)
{
  cout<<*it<<" ";
}

for(auto it: st)
{
  cout<<it<<" ";
}


// To delete an entire set
st.erase(st.begin(), st.end());


Summary :-

Mehtods:
  i.    insert() / emplace()
  ii.   iterators: begin(), end(), rbegin(), rend()
  iii.  erase()
  iv.   find()
  v.    size()
  
All operations on set have log(n) time complexity, which is pretty good.
  
  
  



___________________________________________________________________________________________________________________________________________________________






// Unordered Set:




unordered_set<int> st;

Here the avg case time complexity is O(1)
But the avg case time complexity is O(n).

We should use unordered_set whenever we don't need to store the elements in ascending order because it has a better avg case time complextiy.
But if the problem will give TLE using unordered_set, then we need to switch to set.
TLE indicates the worst case of unordered_set is occurring, which is very rare.

All the methods are the same as in set.







__________________________________________________________________________________________________________________________________________________________

Date : 21st May, 2023
________________________________________________________________________________________________________________________________________________________






Multiset:



It allows us to store the same elements.
Elements are stored in ascending order.

Methods:

  insert() / emplace()
  find()  -   returns the iterator to the first elemnt matching if there are multiple similar elements
  erase(element) -   will remove all occurrences of the element
  clear() -   clears the entire set
  
  
  // to erase multiple instances, we can use:
  ms.erase(ms.find(2));
  ms.erase(ms.find(2), ms.find(2)+2)    --> will erase the next two instances of 2
  
 Time complexity : O(log n)
  
  
  
__________________________________________________________________________________________________________________________________________________________
  
  
  
  
  
  
Map:
 
 
 Stores key value pairs.
 Always sorted in linearly increasing order according to the keys.
 
 map<string, int> mpp;
 mpp["raj"]=43;
 mpp["sandeep"]=34;
 mpp["hima"]=86;
 mpp["raj"]=12;
 
 raj key will now store 12 as its value
 
 Map always stores unique keys. Thus when the same key occurs, the value stored in the key gets overwritten.
 
 mpp.emplace("raj", 45);    --> overwrites in the same manner
 mpp.erase(mpp.find("raj"));  
 mpp.erase(mpp.begin());    --> erases the first element
 
  
